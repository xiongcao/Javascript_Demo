<title>选择排序</title>
<pre>

  + 排序算法
    1.排序算法有很多：冒泡排序/选择排序/插入排序/归并排序/计数排序( counting sort)/
      基数排序(radix sort)/希尔排序/堆排序/桶排序；
    2.我们这里不——列举它们的实现思想，而是选择几个 简单排序 和 高级排序；
    3.简单排序：冒泡排序 - 选择排序 - 插入排序；
    4.高级排序：希尔排序 - 快速排序。

  + 思路
    1.取第一个数，和其他数依次比较，获得最小的数，将最小的数与第一个数交换位置，，这样第一个数就是最小的数；
    2.依次取2、3、4...个数，重复第一步；


  + 代码解析
    1.取一个临时变量min，表示最小值的索引；
    2.取第一个数，去和其他数比较，当arr[min] > arr[other]时，min = other;
    3.一轮比较下来之后，min就是最小值的索引，然后与第一个数 交换位置，这样第一个数就是最小的数；
    4.取第二个数，循环以上操作，得到剩余元素中最小的值，与第二个数交换位置；
    5.重复以上步骤，即可排序；

  + 比较次数：
    假如一共有7个数字；
    第一次循环6次比较，第二次5次比较，第三次4次比较…到最后一趟进行了1次比较；
    对于7个数据项比较次数：6+5+4+3+2+1；
    对于N个数据项：(N-1)+(N-2)+(N-3)+…+1 = N*(N-1)/2。
    

  + 选择排序的O表示法：
    与冒泡排序一样，O(N²)；
    
  
  + 选择排序交换次数：
    1.每次比较最多（也可能不交换）只需要交换一次，一共需要 N-1 次;
    2.用大O表示法，就是O(N);
    3.所以选择排序通常认为在执行效率上是 高于 冒泡排序的。
    

</pre>

<script>

  function ArrayList() {
    this.array = [];

    // 插入数据
    ArrayList.prototype.insert = function (item) {
      this.array.push(item);
    }

    ArrayList.prototype.toString = function () {
      return this.array.join('-')
    }


    ArrayList.prototype.swap = function (m, n) {
      let temp = this.array[m];
      this.array[m] = this.array[n];
      this.array[n] = temp;
    }

    ArrayList.prototype.selectionSort = function () {
      const len = this.array.length;
      let min = 0;

      for (let j = 0; j < len - 1; j++) {
        min = j;

        for (i = min + 1; i < len; i++) {
          if (this.array[min] > this.array[i]) {
            min = i;
          }
        }

        this.swap(min, j);

      }

    }

  }

  const list = new ArrayList();

  list.insert(66)
  list.insert(88)
  list.insert(11)
  list.insert(99)
  list.insert(12)
  list.insert(87)
  list.insert(33)
  list.insert(100)
  list.insert(77)

  console.log('原始数据：', list.toString());

  list.selectionSort();
  console.log('排序之后的数据：', list.toString());

</script>

<style>
  pre {
    font-size: 14px;
  }
</style>